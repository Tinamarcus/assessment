name: Build and Deploy Application

on:
  push:
    branches:
      - main
    paths:
      - 'tasky-main/**'
  workflow_run:
    workflows: ["Deploy Infrastructure"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: tasky

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    # Only run if triggered by workflow_run and the infrastructure pipeline succeeded
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' || github.event_name != 'workflow_run'
    permissions:
      actions: read
      contents: read
      security-events: write

    steps:
    - name: Set commit SHA
      id: vars
      run: |
        if [ "${{ github.event_name }}" == "workflow_run" ]; then
          echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
        else
          echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Checkout
      uses: actions/checkout@v4
      with:
        # When triggered by workflow_run, use the commit from that workflow
        ref: ${{ steps.vars.outputs.sha }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Ensure ECR repository exists
      run: |
        aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" --region "${{ env.AWS_REGION }}" >/dev/null 2>&1 || \
        aws ecr create-repository --repository-name "${{ env.ECR_REPOSITORY }}" --region "${{ env.AWS_REGION }}" >/dev/null

    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./tasky-main
        push: false
        tags: |
          ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        load: true

    - name: Run Trivy vulnerability scanner on container image
      id: trivy-scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        exit-code: '0'
        severity: 'CRITICAL,HIGH'
        ignore-unfixed: false

    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@v4
      # If GitHub Code Scanning / GHAS isn't enabled, don't fail the deploy
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Run Go security scan (gosec)
      uses: securego/gosec@master
      with:
        args: '-no-fail -fmt sarif -out gosec-results.sarif ./tasky-main/...'
      continue-on-error: true

    - name: Upload Go security results
      uses: github/codeql-action/upload-sarif@v4
      if: always()
      continue-on-error: true
      with:
        sarif_file: gosec-results.sarif

    - name: Push Docker image to registry
      if: success()
      uses: docker/build-push-action@v5
      with:
        context: ./tasky-main
        push: true
        tags: |
          ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate Kubernetes manifests from templates (Terraform outputs)
      run: |
        # Resolve runtime values
        export container_image="${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.sha }}"

        # Pull Terraform outputs from remote state
        terraform -chdir=infrastructure init -input=false
        export mongodb_private_ip="$(terraform -chdir=infrastructure output -raw mongodb_vm_private_ip)"

        if [ -z "$mongodb_private_ip" ]; then
          echo "mongodb_vm_private_ip output is empty" >&2
          exit 1
        fi

        # Generate manifests from templates
        mkdir -p kubernetes
        envsubst < kubernetes/templates/deployment.yaml.tpl > kubernetes/deployment.yaml
        cp kubernetes/templates/ingress.yaml.tpl kubernetes/ingress.yaml

        echo "Generated kubernetes/deployment.yaml and kubernetes/ingress.yaml"
        echo "Using image: $container_image"
        echo "Using MongoDB private IP: $mongodb_private_ip"

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name wiz-exercise-cluster --region ${{ env.AWS_REGION }}

    - name: Deploy to Kubernetes
      run: |
        # Apply all Kubernetes manifests
        kubectl apply -f kubernetes/
        
        # Wait for rollout
        kubectl rollout status deployment/tasky-app -n wiz-exercise --timeout=5m

