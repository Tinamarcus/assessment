name: Destroy

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: "Type DESTROY to confirm. This will delete the entire resources."
        required: true
        type: string
      aws_region:
        description: "AWS region"
        required: true
        default: "us-east-2"
        type: string
      cluster_name:
        description: "EKS cluster name (used for pre-destroy cleanup)"
        required: true
        default: "wiz-exercise-cluster"
        type: string

permissions:
  contents: read

concurrency:
  group: wiz-exercise-destroy
  cancel-in-progress: false

jobs:
  destroy:
    name: Destroy all resources
    environment: destroy
    runs-on: ubuntu-latest

    steps:
      - name: Require typed confirmation
        run: |
          if [ "${{ inputs.confirm }}" != "DESTROY" ]; then
            echo "Refusing to run: inputs.confirm must equal DESTROY"
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Install tools (kubectl + terraform)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y unzip jq

          # kubectl
          curl -sSLo /usr/local/bin/kubectl "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x /usr/local/bin/kubectl

          # terraform
          TF_VERSION="1.5.5"
          curl -sSLo /tmp/terraform.zip "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
          sudo unzip -o /tmp/terraform.zip -d /usr/local/bin
          terraform -version

      - name: Pre-destroy cleanup (delete ingress/app to allow ALB teardown)
        run: |
          set -euo pipefail

          if aws eks describe-cluster --name "${{ inputs.cluster_name }}" --region "${{ inputs.aws_region }}" >/dev/null 2>&1; then
            aws eks update-kubeconfig --name "${{ inputs.cluster_name }}" --region "${{ inputs.aws_region }}"

            # Delete app manifests (ignore if already gone)
            kubectl delete -f kubernetes/ --ignore-not-found=true || true

            # Give the controller some time to delete ALB resources
            for i in $(seq 1 30); do
              echo "Waiting for ingress cleanup ($i/30)..."
              if ! kubectl get ingress -A 2>/dev/null | grep -q "alb"; then
                break
              fi
              sleep 10
            done
          else
            echo "EKS cluster not found; skipping kubectl cleanup."
          fi

      - name: Terraform init
        working-directory: infrastructure
        run: terraform init -input=false

      - name: Pre-destroy cleanup (empty S3 buckets + delete ECR images)
        env:
          AWS_REGION: ${{ inputs.aws_region }}
        run: |
          set -euo pipefail

          cd infrastructure

          echo "Pulling Terraform state to discover managed resources..."
          terraform state pull > /tmp/tfstate.json

          echo "Discovering managed S3 buckets..."
          # Extract bucket names from state for aws_s3_bucket resources
          mapfile -t BUCKETS < <(
            jq -r '
              .resources[]
              | select(.type == "aws_s3_bucket")
              | .instances[]
              | .attributes.bucket
            ' /tmp/tfstate.json | sort -u
          )

          if [ "${#BUCKETS[@]}" -eq 0 ]; then
            echo "No S3 buckets found in state."
          else
            echo "Buckets found:"
            printf '%s\n' "${BUCKETS[@]}"
          fi

          empty_versioned_bucket () {
            local bucket="$1"
            echo "Emptying versioned bucket: ${bucket}"

            # Delete object versions + delete markers in chunks of 1000
            while : ; do
              local payload
              payload="$(aws s3api list-object-versions \
                --region "$AWS_REGION" \
                --bucket "$bucket" \
                --max-items 1000 \
                --output json \
                --query '{Objects: (Versions[].{Key:Key,VersionId:VersionId} || `[]`) + (DeleteMarkers[].{Key:Key,VersionId:VersionId} || `[]`)}')"

              local count
              count="$(echo "$payload" | jq -r '.Objects | length')"
              if [ "$count" -eq 0 ]; then
                break
              fi

              aws s3api delete-objects \
                --region "$AWS_REGION" \
                --bucket "$bucket" \
                --delete "$payload" >/dev/null
            done

            # Also remove any remaining non-versioned objects (should be none, but harmless)
            aws s3 rm "s3://${bucket}" --region "$AWS_REGION" --recursive >/dev/null || true
            echo "Emptied: ${bucket}"
          }

          for b in "${BUCKETS[@]}"; do
            # Don't fail the workflow if a bucket is already gone.
            if aws s3api head-bucket --region "$AWS_REGION" --bucket "$b" >/dev/null 2>&1; then
              empty_versioned_bucket "$b"
            else
              echo "Bucket not found (skipping): ${b}"
            fi
          done

          echo "Discovering managed ECR repositories..."
          mapfile -t REPOS < <(
            jq -r '
              .resources[]
              | select(.type == "aws_ecr_repository")
              | .instances[]
              | .attributes.name
            ' /tmp/tfstate.json | sort -u
          )

          if [ "${#REPOS[@]}" -eq 0 ]; then
            echo "No ECR repositories found in state."
          else
            echo "ECR repositories found:"
            printf '%s\n' "${REPOS[@]}"
          fi

          for repo in "${REPOS[@]}"; do
            echo "Deleting images in ECR repo: ${repo}"
            # Delete in batches (ECR batch-delete max 100 per call)
            while : ; do
              mapfile -t IMAGES < <(
                aws ecr list-images \
                  --region "$AWS_REGION" \
                  --repository-name "$repo" \
                  --query 'imageIds[*]' \
                  --output json | jq -c '.[]' | head -n 100
              )

              if [ "${#IMAGES[@]}" -eq 0 ]; then
                break
              fi

              # Build JSON array for batch-delete-image
              printf '%s\n' "${IMAGES[@]}" | jq -cs '.' > /tmp/ecr_image_ids.json
              aws ecr batch-delete-image \
                --region "$AWS_REGION" \
                --repository-name "$repo" \
                --image-ids file:///tmp/ecr_image_ids.json >/dev/null || true
            done
            echo "Images deleted (or none present): ${repo}"
          done

      - name: Terraform destroy
        working-directory: infrastructure
        env:
          TF_IN_AUTOMATION: "true"
        run: terraform destroy -auto-approve -input=false


